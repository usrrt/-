1. 완전탐색과 백트래킹
완전탐색
	- 모든 경우의 수를 탐색하는 알고리즘 = 노가다

모든 경우의 수
	- 순열 or 조합 + 로직
		- 순서와 상관 = 순열
		- 순서와 상관x = 조합

언제 써야하나?
	- 시간복잡도가 보통 1억미만이면 ㄱㄱ

완전탐색은 반복문 or 재귀를 활용한다
	- 반복문으로 구현되면 재귀보다 반복문이 더 빠름 당연함

재귀함수로 구현하는 상황
	- 너무 복잡하거나 어떠한 행위는 반복하는데 매개변수만 수정해서 넘기는 상황
		- 조합 or 순열 + DFS 등 알고리즘
		- 모든 경우의 수마다 생각해야하는 로직

재귀를 활용한 완전탐색 예시
ex) 스즈메는 도쿄위 빨간구름위에 올라가있다. 이 구름을 그대로 내버려두면 땅으로 떨어져 100만의 사상자가 발생한다. 구름을 멈추는 방법은 구름의 특정위치에 요석을 꽂으면 된다. 해당 위치에는 숫자가 표시되어 있고 몇개를 골라 숫자의 합이 "소수" 가 될 때 구름은 멈춘다. 총 몇개의 경우의 수가 있는가? 
  N 개의 요석 후보의 숫자 다음줄에 해당 숫자들이 나온다
  10
  24 35 38 40 49 59 60 67 83 98

해당 숫자를 포함하냐 포함하지 않느냐 는 두가지의 경우의 수가 나옴
 -> {1, 4, 5}에서 x, 1, 4, 5, [1, 4], [1, 5], [4, 5], [1, 4, 5]
 -> 2^3개의 경우의 수
 -> N개일 경우 2^N의 경우의 수
이것을 재귀로 생각하면
	- go라는 함수를 호출할때 포함하냐 포함하지 않느냐로 생각
		- 1을 포함하냐 포함하지않느냐 => 2개 go
			- 4를 포함하냐 포함하지 않느냐 => 2*2개 go
				- 5를 포함하냐 포함하지 않느냐 => 2*2*2개 go

n을 입력받고
n번 만큼 숫자를 입력받는다
	입력받은 숫자를 vector에 저장
go를 호출한다(처음 idx = 0, sum = 0)

go(인덱스 파라미터, 합 파라미터)
	모든 인덱스 탐색이 끝났다면(idx == n)
		소수판별 함수를 호출하여 요소 숫자들의 합이 소수인지 판별한다
	go(idx + 1, sum + vector[idx])(값을 포함한 경우) + go(idx + 1, sum)(값을 제외한 경우)

소수판별
	1 보다 작거나 같지 않아야한다
	2 면 소수다
	2로 나누어 떨어지면 소수가 아니다(짝수)
	모듈로 연산해서 배수(2의 배수, 3의 배수...)면 소수가 아니다
	이외는 모두 소수로 본다


백트래킹
	- 완전탐색 & 가지치기 => 최대한 불필요한 탐색을 피함

